BloxelPlugin for Bevy
-

This plugin provides a voxel world for Bevy, similar to games like Minecraft,
Dragon Quest Builders, Cube World, Super Voxel World, and others.

# General goal

BloxelPlugin needs to do the following.

## World Grid

Create a world grid addressable a `IVec3`.  The world grid is for placed
objects such as blocks, not moving ones such as characters or projectiles.

`IVec3` is Bevy's `i32` 3-dimensional vector.  For a 1 meter cube, as in most
games, the grid should aligns to integer coordinates: (-32,15,7) is the `Vec3`
coordinate (-32,15,7).

The world grid does not scale.  For a 1/2 meter cube, these same coordinates
would be in the world at `Vec3` coordinate (-16,7.5,3.5); however, the player
interacts with the world grid by placing, destroying, and interacting with
objects on the grid, and placing extremely small objects aligned to an
extremely small grid would be difficult.  For games like Teardown this might
be interesting, but it's not a goal here.

Objects can be taken off the grid and moved in the physical world, then placed
back onto the grid when they settle.

### Chunks

Grids can be created such that they are then movable as game objects.  This for
example allows the building of vehicles or the movement of a complex object to
a location on the grid, where it can then be placed by moving those objects
into the main world grid.

More generally, the "world grid" is just a subgrid treated as such, and grids
can be merged into other grids, while areas of grids can be split off into
separate subgrids.

## Manage blocks

Managing blocks on the world grid has performance implications.  A face of
5×5 blocks provides 25 cubic hitboxes.  These don't need collision checks with
eachother, but do need collision checks with everything else.  They do need
individual rendering, however.

Alternatively, cubes could be combined into single, larger composite objects.
This reduces the number of objects to render.  Although AABB is efficient, AABB
on a single cuboid rather than 25 cuboids is even more efficient.  On
collision, the location oft he collision must be ascertained, and the game must
behave as if the collision occurred with the single object in that coordinate
as if they weren't a single composite object.

Further, blocks can be removed from rendering if they are behind other blocks.
A 5×5 cube encases a 3x3 cube, and all blocks making up this 3x3 cube can be
deleted from the world as objects; their entities continue to exist, and the
ECM system still processes them, but they don't have a corresponding 3D shape
in the rendering pipeline.  Breaking a block occluding another block must both
reshape the composited object and instantiate a rendered object, either as
part of a new composite object or as its own separate object.

BloxelPlugin must handle all of this while the programmer only places objects
on the grid.

## Manage non-block objects

Besides blocks, objects like chairs, tables, fences, doors, and so forth are
placed on the grid.  These also need to be managed.  They may be interactable.

## Extensible objects

Some objects change shape when placed side by side.  For example, fence posts
may build out into a fence, and windows may become broad glass sheets.

BloxelPlugin must handle combining these objects and changing the models to
match.  This can be done by triggering actions controlled by the programmer; a
9-slice style generic approach should be provided as well.

# Details

## Chunks

Voxels are placed in cubes of 32 length, totaling 1,024 voxels per chunk.
These are the main unit of interest in the world, and each chunk has a
location on the world grid.

Chunking allows locations to be stored in a 16-bit integer, 5 bits per
dimension.  A voxel will be at a location on the `x`, `y`, and `z` axes from 0
to 31.

Chunks are stored in memory run-length encoded (RLE).  Each chunk uses a
`BTreeMap` to track both voxels and props.  The `BTreeMap` is indexed by the
location as a `u16`, and contains the type of block and a `u16` indicating the
run length in the `x`, `y`, and `z` dimensions.  A run length of 0 indicates
one block; a run length of 31 indicates a 32-block wide span.

## Greedy Meshing

Voxel data in chunks are managed by a binary greedy meshing algorithm.  The
bitmaps for greedy meshing are generated by first using the RLE data to mask
multiple bits on for each `u32` in the bitmap.  Then an ordered list of deltas
is used to mask additional bits on and off, such that each change requires one
bitwise operation.  Breaking a block changes exactly one location, and requires
little work at this stage; breaking many blocks may require more operations.

Greedy meshing produces a run-length encoded description of the chunk, hence
RLE is used for greedy meshing, and the RLE is produced by the greedy mesher.

### Rendering

When rendering, the voxel data will be searched for T-joints.  These are noted
in a `BTreeMap` for the `u16` location of the given box of voxels.  For each
box, if no entry exists in the T-joint map, then the RLE data is used to draw a
`shape::Box`.  If an entry does exist in the T-joint map, then a custom mesh is
created with vertices at each position where a T-joint was detected.

Because Bevy renders `shape::Box` via instancing, using `shape::Box` reduces
draw calls, improving rendering performance and memory efficiency.  Custom
meshes require their own individual draw calls, so minimizing the number of
custom meshes improves performance.

### Hitboxes

The voxel data will be used to directly create hitboxes, with their size and
position determined by the RLE size and position.

### Storage

On-disk storage of chunks uses files containing sets of chunks.  For example,
a file may contain 8x8x8 chunks.

A chunk map file has the below structure:

```
Name          Bytes  Description
INDEX_OFFSET      2  16 bit seek index (base 0) of the chunk index
PALETTE_REFERENCE x  String indicating the location of the palette file
CHUNK_INDEX       x  Chunk index referenced in INDEX_OFFSET
```

The chunk index is linear, with one entry per possible chunk, for 512 entries.
For a chunk at location `(x,y,z)` on an 8x8x8 grid of chunks, the index is
`64x+8y+z`.  Each entry in the index is formatted as follows:

```
Name        Bytes   Detail
FILE_OFFSET     4   Location in the file containing the data
SCAN_OFFSET     4   Distance to traverse from FILE_OFFSET
CHUNK_SIZE      2   Size of the chunk in number of voxels+props
COMPRESS        1   Compression used
```

This is 13 bytes times 512 entries, or 5.5KiB.  Crucially, empty chunks have
`CHUNK_SIZE=0` and should have all other entries as `0`, and are not read.  No
chunk data needs to exist in the file for an empty chunk.

`FILE_OFFSET` indicates where in the file to begin scanning.  This location may
represent a stream of compressed data containing multiple chunks.

`SCAN_OFFSET` indicates how far from the beginning of the chunk data to start
reading.  If the chunk is in a compressed stream, this much decompressed data
will be skipped.

`CHUNK_SIZE` indicates the size of the chunk data.

`COMPRESS` indicates if the location is a compressed stream.  A value of `1`
indicates `lz4` compression; `0` is uncompressed.

This allows striking a balance between on-disk size and access speed.

Each chunk contains a stream of RLE data.  This data includes voxels and props.
Each RLE entry is as follows:

```
Name         Bytes  Description
PALETTE          3  The palette index for the type of prop or block.
IS_PROP          0  The first bit of RLE_ADDRESS is `1` for props.
RLE_ADDRESS      2  Encoded `0bp_xxxxx_yyyyy_zzzzz` base location.
RLE_SPAN         2  Encoded `0b0_xxxxx_yyyyy_zzzzz` span.
```

This is 7 bytes.  `RLE_SPAN` is ignored for props, and should be `0`.

As a chunk is 32×32×32, up to 32,768 objects or 224KiB can be occupied per
chunk.

On top of this, the chunk ends with a rotation table of 16KiB, bringing the
total maximum chunk size to 240KiB.  Chunks containing exactly 1 entry are
exactly 16KiB plus 7 bytes.

A chunk file thus represents 512 chunks, a total of 2^24 voxel locations, and
a maximum of 120MiB plus the header and index.  Empty chunks consume no space;
if all 512 chunks contain 1 RLE entry each, then the minimum size is just above
8MiB; and chunks can be compressed to reduce the size of the rotation table.

This approach allows minimized storage.  Save files can be directories of chunk
files for modified chunks; unmodified chunks can be procedurally generated or
read from the base location.